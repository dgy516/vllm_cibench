name: ci
on:
  pull_request:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  lint:
    name: lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: 'pip'
          cache-dependency-path: |
            requirements.txt
            requirements-dev.txt
      - run: pip install -r requirements-dev.txt
      - run: ruff check src tests
      - run: black --check src tests
      - run: isort --check-only src tests

  typecheck:
    name: typecheck
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: 'pip'
          cache-dependency-path: |
            requirements.txt
            requirements-dev.txt
      - run: pip install -r requirements-dev.txt
      - run: mypy --strict src

  test:
    name: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: 'pip'
          cache-dependency-path: |
            requirements.txt
            requirements-dev.txt
      - run: pip install -r requirements-dev.txt
      - run: pytest -q -m "not slow"
      - name: orchestrator smoke (dry run)
        run: |
          python - <<'PY'
          import shutil, yaml
          from pathlib import Path
          src = Path('configs')
          root = Path('smoke_configs')
          dst = root / 'configs'
          shutil.copytree(src, dst, dirs_exist_ok=True)
          matrix = yaml.safe_load((dst / 'matrix.yaml').read_text())
          keep = 'local_single_qwen3-32b_guided_w8a8'
          matrix = {keep: matrix[keep]}
          (dst / 'matrix.yaml').write_text(yaml.safe_dump(matrix))
          PY
          PYTHONPATH=src python -m vllm_cibench.run run --scenario local_single_qwen3-32b_guided_w8a8 --run-type pr --root smoke_configs --dry-run --timeout 0.5 > smoke_run.json
          PYTHONPATH=src python -m vllm_cibench.run run-matrix --run-type pr --root smoke_configs --dry-run --timeout 0.5 > smoke_matrix.json
          cat smoke_run.json
          cat smoke_matrix.json
          python - <<'PY'
          import json, os
          run = json.load(open('smoke_run.json'))
          matrix = json.load(open('smoke_matrix.json'))
          lines = [f"single: func={run.get('functional')}, perf={bool(run.get('perf_metrics'))}"]
          for sid, res in matrix.items():
              lines.append(f"{sid}: func={res.get('functional')}, perf={bool(res.get('perf_metrics'))}")
          summary = '\n'.join(f"- {l}" for l in lines)
          with open(os.environ['GITHUB_STEP_SUMMARY'], 'a', encoding='utf-8') as fh:
              fh.write('### Orchestrator Smoke\n')
              fh.write(summary + '\n')
          PY

      - name: Upload smoke artifacts (PR retention 14 days)
        uses: actions/upload-artifact@v4
        with:
          name: pr-smoke-artifacts
          path: |
            smoke_run.json
            smoke_matrix.json
          if-no-files-found: warn
          retention-days: 14

  gate:
    name: gate
    runs-on: ubuntu-latest
    needs: [lint, typecheck, test]
    steps:
      - name: Download smoke artifacts
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: pr-smoke-artifacts
          path: pr-smoke
      - name: Gate on smoke functional (best-effort)
        run: |
          python - <<'PY'
          import json, os, sys, pathlib
          p = pathlib.Path('pr-smoke/smoke_run.json')
          if not p.exists():
            print('No smoke_run.json found; skipping gate.')
            sys.exit(0)
          try:
            run = json.loads(p.read_text())
          except Exception as e:
            print(f'Failed to parse smoke_run.json: {e}; skipping gate.')
            sys.exit(0)
          func = run.get('functional')
          print(f'functional={func}')
          # Gate only on explicit failure; pass/ok/None treated as pass
          if func == 'failed':
            print('Gate failed: smoke functional failed')
            sys.exit(1)
          print('Gate satisfied')
          PY
